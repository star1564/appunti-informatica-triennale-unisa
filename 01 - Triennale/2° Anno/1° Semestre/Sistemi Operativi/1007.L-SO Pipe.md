---
aliases: 
tags:
  - corsi/informatica/sistemi_operativi
paragrafo: Laboratorio SO
cssclasses:
  - 
---
Le **Pipe** (Tubi) servono per la *comunicazione tra processi*. Il flusso di dati è in una sola direzione e possono essere utilizzate solo tra processi he hanno un antenato in comune.

```C
#include <unistd.h>

int pipe(int filedes[2]);
```

**Restituisce**:
- *0* se OK;
- *-1* altrimenti.

L'array `filedes` è il canale in cui i processi comunicano. I due elementi al suo interno hanno le seguenti funzioni:
- ***`filedes[0]`*** è il [[009 Apertura di un file#^8ad3ec|File Descriptor]] di un "file" aperto in **Lettura**;
- ***`filedes[1]`*** è il File Descriptor di un "file" aperto in **Scrittura**.
	- inoltre il suo output corrisponde all'input di `filedes[0]`.

Si crea l'array di file descriptor, la si fa diventare una pipe con la funzione descritta sopra, si fa la [[1006.L-SO Controllo Processi#FORK|fork]] del processo.

Dopo di questo si imposta il processo padre come mittente ed il figlio come destinatario con la funzione `close()`:
- Nel padre: `close(filedes[0])`;
- Nel figlio: `close(filedes[1])`.
Solo a quel punto è possibile far comunicare il processo padre con il processo figlio.

Se si vuole fare l'opposto:
- Nel padre: `close(filedes[1])`;
- Nel figlio: `close(filedes[0])`.

> [!example]- <font color="orange">Esempio Funzionamento basilare pipe</font>
>```C
>#include <unistd.h>
>#include <stdio.h>
>#include <stdlib.h>
>#include <string.h>
>
>int main() {
>	int pipefd[2];
>	char buf[100];
>	
>	if (pipe(pipefd) == -1) {
>		printf("Errore pipe\n");
>		return 0;
>	}
>	
>	int pid = fork();
>	if (pid == -1) {
>		printf("Errore fork\n");
>		return 0;
>	}
>	
>	if (pid > 0) {  // Processo padre
>		close(pipefd[0]); // Chiudi la parte di lettura della pipe
>		
>		// Scrivi nella pipe
>		const char *messaggio = "Hello from the parent!";
>		if (write(pipefd[1], messaggio, strlen(messaggio)) == -1) {
>			 printf("Errore write\n");
>			 return 0;
>		}
>		
>		printf("Il padre ha mandato: %s\n", messaggio);
>	}
>	else { // Processo figlio
>		close(pipefd[1]); // Chiudi la parte di scrittura della pipe
>		
>		// Leggi dalla pipe
>		 if (read(pipefd[0], buf, sizeof(buf)) == -1) {
>			 printf("Errore read\n");
>			 return 0;
>		}
>		
>		printf("Il figlio ha ricevuto: %s\n", buf);
>	}
>	
>	return 0;
>}
>```
>![[Pasted image 20221216171739.png]]



___
%%
Tag Materia: #corsi/informatica/sistemi_operativi 
%%
[[000 Indice SO|↖ Ritorna all'indice ↖]] , [[1006.L-SO Controllo Processi|← Nota Precedente]]

Altri collegamenti: 