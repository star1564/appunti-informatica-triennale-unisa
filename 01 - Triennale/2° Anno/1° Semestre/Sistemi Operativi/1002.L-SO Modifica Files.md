---
aliases: 
tags:
  - corsi/informatica/sistemi_operativi
paragrafo: Laboratorio SO
cssclasses:
  - 
---
Per creare e modificare file in C *senza utilizzare programmi* di editing, si usano le [[005 Chiamate di Sistema|chiamate di sistema]] di I/O.
Queste funzioni utilizzano il [[009 Apertura di un file#^8ad3ec|file descriptor (fd)]] di un file per poterci lavorare.

> [!tip] Utilizzare il comando `man`*`comando`* per ulteriori informazioni

---
# IMPORTANTI
## OPEN
La **`open()`** viene usata per *aprire un file (o per crearlo se non esiste)*.

```C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open (const char *pathname, int oflag /*, mode_t mode*/);
```

**Parametri**: 
- *`pathname`*: il path del file che si vuole aprire o creare (si vede nella directory attuale se gli viene dato solo il nome del file);

- *`oflag`*: indica come si vuole usare il file. È formato dall'[[003 OR (MMI)|OR]] di uno o più dei flag di stato:
	- **Una ed una sola** costante tra:
		- `O_RDONLY`: sola scrittura; 
		- `O_WRONLY`: sola lettura; 
		- `O_RDWR`: lettura e scrittura.
	- (**Opzionale**) Una qualunque tra:
		- `O_APPEND`: tutto ciò che verrà scritto sarà posto alla fine;
		- `O_CREAT`: usato quando si usa open *per creare un file*;
		- `O_EXCL`: messo in OR con `O_CREAT` per *segnalare errore se il file già esiste* (ritornando -1);
		- `O_TRUNC`: elimina tutto quello che ci sta nel file se si esegue una scrittura;
		- `O_SYNC`: se si sta aprendo in write, fa completare prima I/O;
		- `O_NOCTTY`, `O_NONBLOCK`.

- *`mode`*: viene utilizzato quando si crea un nuovo file utilizzando `O_CREAT` per specificare i permessi di accesso del nuovo file che si sta creando ([[1004.L-SO Accesso ai File#CHMOD - FCHMOD|chmod ↩]]). Se il file già esiste questo argomento viene ignorato.
> [!summary]- Costanti per i permessi (mode)
> ![[Pasted image 20221018153220.png|500]]


**Restituisce**:
- Il file *descriptor del file* aperto se OK;
- Altrimenti *-1*.

**Come funziona nel SO**:
- Cerca il file esistente nel disco;
- Se il file non esiste lo crea;
- Crea una nuova entry nella [[009 Apertura di un file#^d52b90|tabella dei file aperti da un processo]];
- Fai puntare il primo fd non utilizzato al file;
- Restituisci il risultato.

> [!example]- <font color="orange">Esempio</font>
>```C
>#include <sys/types.h>
>#include <sys/stat.h>
>#include <fcntl.h>
>#include <stdio.h>
>
>int main(){	
>	// Apri il file "foo.txt" nella directory locale.
>	// Se non esiste crealo, dando il permesso all'utente, al gruppo ed a tutti quanti di
>	// scrittura, lettura, esecuzione.
>	int fd = open("foo.txt", O_RDWR | O_CREAT, S_IRWXU | S_IRWXG | S_IRWXO);
>
>	printf("fd = %d\n", fd);
>	
>	if (fd == -1)
>		printf("Impossibile aprire il file\n");
>		
>	return 0;
>}
>```

## CLOSE
La **`close()`** viene usata per *chiudere un file*.

```C
#include <fcntl.h>
#include <unistd.h>

int close (int fd);
```

**Parametri**: 
- *`fd`*: il file descriptor;

**Restituisce**:
- *0* se OK;
- Altrimenti *-1*.

**Come funziona nel SO**:
- Se nessun altro processo punta a quel file, elimina l'entry corrispondente al fd ottenuto nella [[009 Apertura di un file#^d52b90|tabella dei file aperti da un processo]];
- Restituisci il risultato.

> [!example]- <font color="orange">Esempio</font>
>```C
>#include <sys/types.h>
>#include <sys/stat.h>
>#include <fcntl.h>
>#include <unistd.h>
>#include <stdio.h>
>
>int main(){	
>	int fd = open("foo.txt", O_RDWR | O_CREAT, S_IRWXU);
>	printf("File aperto: fd = %d\n", fd);
>
>	if (fd == -1)
>		printf("Impossibile aprire il file\n");
>
>	if (close(fd) < 0)
>		printf("Impossibile chiudere il file\n");
>	else
>		printf("File chiuso: fd = %d\n", fd);
>
>	return 0;
>}
>```

## READ
La **`read()`**, dal file con file descriptor `fd`, legge un numero massimo `count` di bytes in input e li mette nella zona di memoria `buf`.

```C
#include <unistd.h>

ssize_t read (int fd, void *buf, size_t count);
```

La lettura parte dal current offset.

**Parametri**: 
- *`fd`*: il file descriptor;
	- Se si vuole *leggere l'input da tastiera* si inserisce `read(STDIN_FILENO, buffer, max)`.
- *`buf`*: buffer nel quale si inserisce l'input;
- *`count`*: numero di bytes da leggere.

**Restituisce**:
- Il *numero di bytes letti*;
- *0* se il current offset inizia dalla fine del file, oppure quando `count` è 0;
- Altrimenti *-1*.

**Comportamenti da Notare**:
- Quando si prende in input da tastiera una stringa, se questa è più grande della dimensione del buffer, non ci scriverà i dati dopo l'ultimo spazio disponibile (Es. `buffer[3]`, input: "Test", scritto nel buffer: "Te" dato che l'ultimo carattere è `\0`, "st" rimane nel buffer del terminale);

> [!example]- <font color="orange">Esempio</font>
>**LETTURA DA FILE**
>```C
>#include <sys/types.h>
>#include <fcntl.h>
>#include <sys/stat.h>
>#include <unistd.h>
>#include <stdio.h>
>#include <stdlib.h>
>
>int main(void) {
>	int fd, i;
>	char *buf = (char *) calloc(20, sizeof(char)); 
>	
>	fd = open("foo.txt", O_RDONLY);
>	
>	if (fd < 0) 
>		printf("Impossibile aprire il file\n");
>	
>	i = read(fd, buf, 20);
>	buf[i] = '\0';
>	
>	printf("File: %d. Bytes Letti: %d\n", fd, i);
>	printf("Dati Letti: %s", buf);
>	return 0;
>}
>```
>
>**LETTURA DA TASTIERA**
>```C
>#include <sys/types.h>
>#include <fcntl.h>
>#include <sys/stat.h>
>#include <unistd.h>
>#include <stdio.h>
>#include <stdlib.h>
>
>int main(void) {
>	int fd = STDIN_FILENO, i; // Qui lo ho messo per mostrare che il fd è 0 (stdin).
>	char *buf = (char *) calloc(20, sizeof(char)); 
>	
>	i = read(STDIN_FILENO, buf, 20);
>	buf[i] = '\0';
>	
>	printf("File: %d. Bytes Letti: %d\n", fd, i);
>	printf("Dati Letti: %s", buf);
>	return 0;
>}
>```
>
>**LEGGERE UN CARATTERE ALLA VOLTA**
>```C
>char buf;
>int cont = 0;
>while (read(fd, &buf, 1)){
>	if(buf == 'a' || buf == 'e' || buf == 'i' || buf == 'o' || buf == 'u')
>		cont++;
>}
>printf("Numero Vocali: %d\n", cont);
>```

## WRITE
La **`write()`**, scrive nel file con file descriptor `fd` un numero massimo di `count` bytes presi dal buffer `buf`.

```C
#include <unistd.h>

ssize_t write (int fd, void *buf, size_t count);
```

La scrittura parte dal current offset.

**Parametri**: 
- *`fd`*: il file descriptor;
	- Se si vuole *stampare a video* si inserisce `write(STDOUT_FILENO, buffer, max)`.
- *`buf`*: buffer dal quale si prendono i dati;
- *`count`*: numero di bytes da scrivere.

**Restituisce**:
- Il *numero di bytes scritti* correttamente;
- *0* se il current offset inizia dalla fine del file, oppure quando `count` è 0;
- Altrimenti *-1*.

> [!example]- <font color="orange">Esempio</font>
>**SCRITTURA SU FILE**
>```C
>#include <sys/types.h>
>#include <fcntl.h>
>#include <sys/stat.h>
>#include <unistd.h>
>#include <stdio.h>
>#include <stdlib.h>
>#include <string.h>
>
>int main(void) {
>	int fd, i;
>	char buf[] = "Ciao, Mondo!";
>	
>	fd = open("foo.txt", O_WRONLY | O_CREAT | O_TRUNC /*Elimina tutto quello che ci sta*/, S_IRWXU | S_IRWXG | S_IRWXO);
>	if (fd < 0){
>		printf("Impossibile aprire il file\n");
>		return 0;
>	}
>	
>	i = write(fd, buf, strlen(buf));
>	printf("File: %d. Bytes Scritti: %d\n", fd, i);
>	
>	return 0;
>}
>```
>**STAMPA A VIDEO**
>```C
>#include <sys/types.h>
>#include <fcntl.h>
>#include <sys/stat.h>
>#include <unistd.h>
>#include <stdio.h>
>#include <stdlib.h>
>#include <string.h>
>
>int main(void) {
>	int fd = STDOUT_FILENO, i;
>	char buf[] = "Ciao, Mondo!\n";
>	
>	i = write(fd, buf, strlen(buf));
>	printf("File: %d. Bytes Scritti: %d\n", fd, i);
>	
>	return 0;
>}
>```

## LSEEK
La **`lseek()`** *riposiziona il Current Offset* del file aperto in un'altra posizione.

```C
#include <sys/types.h>
#include <unistd.h>

off_t lseek (int fd, off_t offset, int whence);
```

**Parametri**: 
- *`fd`*: il file descriptor;
- *`offset`*: posizione in cui spostare il current offset (ogni singolo offset corrisponde ad *un carattere*);
- *`whence`*: modalità con cui eseguire lo spostamento:
	- `SEEK_SET`: ci si sposta del valore di `offset` a partire dall'inizio;
	- `SEEK_CUR`: ci si sposta del valore di `offset` (positivo o negativo) a partire dalla posizione corrente;
	- `SEEK_END`: ci si sposta del valore di `offset` (positivo o negativo) a partire dalla fine del file (taglia).

**Restituisce**:
- *il nuovo offset* se OK (**UTILE** se si vuole sapere la lunghezza del file);
- Altrimenti *-1*.

![[Pasted image 20221021171635.png|500]]


---
# ALTRE
## UMASK
La **`umask()`** imposta la maschera di creazione per l'*accesso* ad un file. È usata ogni volta che il processo crea un nuovo file o directory.

```C
#include <sys/types.h>
#include <sys/stat.h>

mode_t umask (mode_t cmask);
```

**Restituisce**: la maschera di creazione precedente (nota che non restituisce valori di errore).

## OFFSET
Ogni file aperto ha assegnato un **[[009 Apertura di un file#^5aa314|Current Offset]]** che misura in numero di byte la *posizione attuale nel file*.

Operazioni di apertura/creazione come `open` e `creat` impostano il current offset all'inizio del file (a meno che `O_APPEND` sia specificato nella `open`).

Operazioni di lettura/scrittura come `read` e `write` partono dal current offset e causano un incremento pari al numero di byte letti o scritti.

## CREAT
La **`creat()`** viene usata per *creare nuovi file vuoti*.

> [!failure] Questa funzione è decrepita
> La [[#OPEN|open]] esegue la lettura/creazione di un file.

```C
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int creat (const char *pathname, mode_t mode);
```

**Parametri**: 
- *`pathname`*: nome del file da creare;

- *`mode`*: indica i [[Permessi File|permessi]] del nuovo file.

**Restituisce**:
- Il file *descriptor del file* aperto come **write-only** se OK;
- Altrimenti *-1*.

**Come funziona nel SO**:
- Crea un nuovo file vuoto sul disco;
- Crea una nuova entry nella [[009 Apertura di un file#^d52b90|tabella dei file aperti da un processo]];
- Fai puntare il primo fd non utilizzato al file;
- Restituisci il risultato.

---
%%
Tag Materia: #corsi/informatica/sistemi_operativi 
%%

[[000 Indice SO|↖ Ritorna all'indice ↖]] , [[1001.L-SO Comandi Principali|← Nota Precedente]] , [[1003.L-SO Stat|Nota Successiva →]]