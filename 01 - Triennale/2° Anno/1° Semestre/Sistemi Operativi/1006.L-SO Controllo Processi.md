---
aliases: 
tags:
  - corsi/informatica/sistemi_operativi
paragrafo: Laboratorio SO
cssclasses:
  - 
---
Alla fine del boot del SO, il [[Kernel]] legge vari file di configurazione per portare il sistema in uno stato predefinito. 
Questo porta alla creazione del **Primo Processo (init)**, che avrà come [[Process ID|PID]] **1** e non muore mai.

### GETPID
La **`getpid()`** e **`getppid()`** vengono usate per *ottenere il Process ID del processo attuale*.

```C
#include <unistd.h>

pid_t getpid();

pid_t getppid();
```

**Restituisce**:
- *`getpid()`*:
	- il *PID* del processo chiamante.
- *`getppid()`*:
	- il *PID* del padre del processo chiamante.

Queste funzioni vanno sempre a successo.

> [!example]- <font color="orange">Esempio</font>
>```C
>#include <unistd.h>
>#include <stdio.h>
>
>int main(void){
>	printf("PID del processo = %d\n", getpid());
>	return 0;
>}
>```

---
### FORK
La **`fork()`** viene usata per *creare un processo figlio*.

```C
#include <unistd.h>

pid_t fork();
```

**Descrizione**: 
- `fork()` crea un nuovo processo *duplicando il processo chiamante*; condividono dati, stack e heap. 
- Il nuovo processo viene chiamato *figlio*, mentre quello chiamante *padre*.
- Il processo figlio ed il processo padre vengono eseguiti in spazi di memoria differenti.
- Il processo figlio ed il processo padre *eseguono entrambi le istruzioni che seguono la chiamata* `fork()`.

**Restituisce**:
La variabile di tipo `pid_t` in cui va a scrivere la `fork()`, avrà:
-  se OK:
	- il *PID del figlio* nel padre;
	- *0* nel figlio;
-  Altrimenti *-1*.

> [!example]- <font color="orange">Esempio 1</font>
>```C
>#include <stdio.h>
>#include <unistd.h>
>#include <stdlib.h>
>
>int glob = 10;      // Variabile globale
>
>int main(void){
>    int var = 50;   // Variabile locale
>    pid_t processId;
>    printf("Prima della fork\n");
>
>    processId = fork();
>
>    // Supponendo che il processo padre abbia il PID = 200
>    // NEL PROCESSO PADRE  : processId = 201
>    // NEL PROCESSO FIGLIO : processId = 0
>
>    if(processId == 0){ // Qui entrerà il processo figlio
>        glob++;
>        var++;
>    }
>    else                // Qui entrerà il processo padre
>        sleep(2);
>
>    // Il primo a finire sarà il figlio, specificando il suo VERO PID
>    printf("PID = %d, glob = %d, var = %d\n", getpid(), glob, var);
>	exit(0);
>}
>```
>Output:
>```markup
>Prima della fork
>PID = 201, glob = 11, var = 51
>/* ATTESA DI 2 SECONDI */
>PID = 200, glob = 10, var = 50
>```
>![[Pasted image 20221112143235.png|700]]
>Dove:
>- PID PADRE : 200;
>- PID FIGLIO : 201.

> [!example]- <font color="orange">Esempio 2 (con grafico)</font>
> > Supponendo che il processo chiamante PADRE abbia come PID 200. Dire quanti nuovi processi verranno generati all'esecuzione del seguente codice.
>```C
>//...
>int main (void){
>	pid_t pid1, pid2;
>	pid1 = fork();    // PADRE crea FIGLIO 1
>	pid2 = fork();    // PADRE crea FIGLIO 2; FIGLIO 1 crea FIGLIO EX
>	exit(0);
>}
>```
>
>![[Pasted image 20221112141443.png|Vengono generati 3 nuovi processi|650]]
>Dove:
>- PID PADRE : 200;
>- PID FIGLIO 1 : 201;
>- PID FIGLIO 2 : 202;
>- PID FILGIO EX : 203.

> [!example]- <font color="orange">Esempio 3 (con grafico)</font>
> > Supponendo che il processo chiamante PADRE abbia come PID 200. Dire quanti nuovi processi verranno generati all'esecuzione del seguente codice.
>```C
>//...
>int main (void){
>	pid_t pid1, pid2;
>	pid1 = fork();    // PADRE crea FIGLIO 1
>	if(pid1 > 0)
>		pid2 = fork();    // PADRE crea FIGLIO 2
>	exit(0);
>}
>```
>
>![[Pasted image 20221112141803.png|Vengono generati 2 nuovi processi|650]]
>Dove:
>- PID PADRE : 200;
>- PID FIGLIO 1 : 201;
>- PID FIGLIO 2 : 202.

---
### EXECL
La **`execl()`** viene usata per mandare in esecuzione *un altro programma*.

```C
#include <unistd.h>

int execl(const char *pathname, const char *arg0/*, const char *argn ...*/, NULL);
```

**Descrizione**: 
- La sua chiamata deve sempre terminare con `NULL` come ultimo argomento;
- Questa funzione *sostituisce* il processo attuale con quello mandato in esecuzione, è pertanto consigliabile creare un figlio con la `fork()` e fargli eseguire il comando;
- Appena il programma caricato finisce, terminerà anche il processo che lo ha mandato in esecuzione (non verrà eseguito nulla dopo la `execl`).

**Parametri**: 
- *`pathname`*: il path del programma che si vuole mandare in esecuzione;
- *`arg0`*: corrisponde all'`argv[0]` che si manda dal terminale, ovvero il nome del programma;
- *`argn`*: corrispondono agli altri argomenti che si mandano dal terminale, è opzionale e dipende dal funzionamento del programma.

> [!example]- <font color="orange">Esempio</font>
> - Il programma `helloPrinter.out` non richiede l'utilizzo degli argv. Questo si trova nella stessa cartella del file `.out` appartenente al processo in esecuzione.
>```C
>execl("./helloPrinter.out", "helloPrinter.out", NULL);
>```
>- Il programma `helloPrinter2.out` non richiede l'utilizzo degli argv. Questo si trova nel path `/usr/bin`.
>```C
>execl("/usr/bin/helloPrinter2.out", "helloPrinter2.out", NULL);
>```
>- Il programma `helloPrinter3.out` richiede l'utilizzo di un solo argv. Questo si trova nella stessa cartella del file `.out` appartenente al processo in esecuzione.
>```C
>execl("./helloPrinter3.out", "helloPrinter3.out", arg, NULL);
>```
>- Il programma `helloPrinter4.out` richiede l'utilizzo di tre argv. Questo si trova nella stessa cartella del file `.out` appartenente al processo in esecuzione.
>```C
>execl("./helloPrinter4.out", "helloPrinter4.out", arg1, arg2, arg3, NULL);
>```
___
%%
Tag Materia: #corsi/informatica/sistemi_operativi 
%%
[[000 Indice SO|↖ Ritorna all'indice ↖]] , [[1005.L-SO Directory|← Nota Precedente]] | [[1007.L-SO Pipe|Nota Successiva →]]

Altri collegamenti: 