---
aliases: 
tags:
  - corsi/informatica/tecnologie_software_web
paragrafo: JavaScript
cssclasses:
  - 
---
>**XML** (eXtensible Markup Language) è un linguaggio di markup che consente di *definire la struttura e il significato dei dati*. È progettato per essere leggibile sia dagli esseri umani che dalle macchine, ed è ampiamente utilizzato per la *memorizzazione e lo scambio di informazioni strutturate* su Internet.

XML utilizza una sintassi simile all'HTML, ma a differenza di quest'ultimo, XML *non ha tag predefiniti*. Invece, gli sviluppatori possono **definire i propri tag** per rappresentare i dati in base alle esigenze specifiche del dominio. Questa flessibilità permette di creare strutture dati personalizzate, rendendo XML estremamente versatile.

È indipendente dal tipo di piattaforma hardware e software su cui viene utilizzato. Esistono numerose applicazioni e librerie in grado di *elaborare dati in formato XML* su diversi linguaggi di programmazione.

I *parser XML* sono diventati strumenti standard nello sviluppo delle applicazioni. In java si utilizzano le specifiche **JAXP** (Java API for XML Processing).

Un parser deve:
- *Decomporre i documenti XML* nei loro elementi costitutivi (elementi, attributi, testo, ecc);
- *Eseguire controlli* sul documento per vedere se è ben formato ed eventualmente se è valido.
	- Non tutti i parser possono eseguire la validazione, perché è un operazione costosa.

---
### Funzionamento
XML organizza i dati in un formato ad [[013 Alberi|albero]] chiamato documento XML. Il documento XML inizia con un elemento radice che contiene tutti gli altri elementi. Gli elementi possono essere *nidificati* all'interno di altri elementi, creando la struttura ad albero.

Gli elementi XML sono definiti attraverso i **tag**. Un tag XML consiste di un *nome* che identifica l'elemento e *può contenere* **attributi** per fornire ulteriori informazioni sul dato rappresentato dall'elemento.

> [!example] <font color="orange">Esempio</font>
>```xml
><persona nome="Mario" età="30">
>  <indirizzo>città di esempio</indirizzo>
></persona>
>```

Gli elementi XML *possono contenere testo o altri elementi nidificati*. Il testo all'interno di un **elemento** è considerato il suo *contenuto*. Nell'esempio sopra, "città di esempio" è il contenuto dell'elemento "indirizzo".

XML consente di creare una *gerarchia di dati* attraverso l'annidamento degli elementi. Questo permette di rappresentare relazioni complesse tra i dati. Ad esempio, un elemento "persona" può contenere elementi "nome", "età" e "indirizzo".

> [!example]- <font color="orange">Esempio</font>
>```XML
><course name="Algebra">
>	<student id="alice">
>		<name>Alice</name>
>		<gender>Female</gender>
>		<comments>Friend of <person ref="bob">Robert</person></comments>
>	</student>
>	<student id="bob">
>		<name>Bob</name>
>		<gender>Male</gender>
>		<birthDate>1981-09-24</birthDate>
>	</student>
></course>
>```
>
>![[Pasted image 20230616110548.png|800]]

---
### Documenti ben formati e validi
In XML, ci sono due concetti chiave: 
- Il documento **Ben Formato** (well-formed). È un documento che *segue le regole di base della sintassi XML*, deve quindi soddisfare i seguenti requisiti:
	- Deve avere *un unico elemento radice* che racchiude tutti gli altri elementi;
	- Ogni elemento deve essere correttamente *aperto e chiuso*;
	- Gli elementi devono essere *correttamente nidificati*, senza sovrapposizioni o intersezioni;
	- Gli attributi degli elementi devono essere dichiarati tra *virgolette doppie o singole*;
	- I caratteri speciali come `<`, `>`, `&`, `"`, `'` devono essere correttamente "*escapeati*".
- Il documento **Valido** (valid). È un documento che *rispetta le regole sintattiche* descritte sopra e *le regole semantiche*, ovvero quando segue un insieme di regole specificate (*schema*).

> [!example]- <font color="orange">Esempio</font>
>```XML
><?xml version="1.0" encoding="UTF-8"?>
><libreria>
>	<libro category="fantasy">
>		<titolo>Il signore degli anelli</titolo>
>		<autore>J.R.R. Tolkien</autore>
>		<anno_pubblicazione>1954</anno_pubblicazione>
>	</libro>
>	<libro category="fantasy">
>		<titolo>Lo Hobbit</titolo>
>		<autore>J.R.R. Tolkien</autore>
>		<anno_pubblicazione>1937</anno_pubblicazione>
>	</libro>
></libreria>
>```
>
>Questo codice è ben formato. Inoltre è anche valido, perché in questo xml (che rappresenta una raccolta di libri), lo schema XML potrebbe specificare che ogni libro deve avere un titolo, un autore e un anno di pubblicazione.

---
### Struttura formale
Un documento XML è composto da due parti:
- **Prologo**, contiene una *dichiarazione XML* ed il *riferimento ad altri documenti* (opzionale) che ne definiscono la grammatica o direttive di elaborazione;
- **Corpo**, il documento vero e proprio.

![[Pasted image 20230616110947.png|500]]

---
### Conflitti sui nomi
Capita abbastanza comunemente, soprattutto in documenti complessi, di *dare nomi uguali* ad elementi o attributi con significati diversi.

> [!example]- <font color="orange">Esempio</font>
>```xml
><libro>
>	<autore>
>		<titolo>Sir</titolo>
>		<nome>William Shakespeare</nome>
>	</autore>
>	<titolo>Romeo and Juliet</titolo>
></libro>
>```

Per risolvere questo problema, si ricorre al concetto di **Namespace** (*spazio dei nomi*), un modo per distinguere gli elementi e gli attributi che provengono da diverse fonti o domini.

In XML, il namespace viene dichiarato utilizzando l'attributo **`xmlns`** (XML namespace) all'interno degli elementi. Questa dichiarazione specifica un prefisso che viene associato a un [[002 URL#^d0254a|URI]] che identifica in modo univoco uno spazio dei nomi.


> [!example]- <font color="orange">Esempio</font>
>```xml
><root xmlns:ns="http://www.example.com">
>  <ns:elemento1>Contenuto 1</ns:elemento1>
>  <ns:elemento2>Contenuto 2</ns:elemento2>
></root>
>```
>
>Qui abbiamo dichiarato uno spazio dei nomi con il prefisso `ns` che è associato all'URI. I due elementi sono prefissati con `ns:`, indicando che appartengono allo spazio dei nomi specificato dall'URI.

___
[[000 Indice TSW|↖ Ritorna all'indice ↖]]

```dataviewjs
/*
function extractUpperCaseLetters(inputString) {
	// Use a regular expression to match uppercase letters (A-Z)
	const uppercaseLetters = inputString.match(/[A-Z]/g);
	
	// Check if uppercaseLetters is not null, and join the matched letters into a string
	if (uppercaseLetters !== null) {
		return uppercaseLetters.join('');
	} else {
	    // If no uppercase letters were found, return an empty string
	    return '';
	}
}
*/

function extractNumberFromString(inputString) {
	const match = inputString.match(/^\d{3}/);
	
	if (match) {
		return match[0];
	} else {
		return null; // Return null if no match is found
	}
}

function startsWithNumber(inputString, targetNumber) {
  // Use a regular expression to check if the string starts with the target number
  const pattern = new RegExp(`^${targetNumber}`);
  return pattern.test(inputString);
}

function sort2Array(array){
	let res = []
	
	if (array[0] == undefined)
		res.push(array[1], array[1])
	else if (array[1] == undefined)
		res.push(array[0], array[0])
	else if (parseInt(extractNumberFromString(array[0])) > parseInt(extractNumberFromString(array[1])))
		res.push(array[1], array[0])
	else
		res.push(array[0], array[1])
	
	return res
}

let toDisplay = []
function searchPrevAndNext(tag, currentNumber) {
	const prevNumber = (parseInt(currentNumber) - 1).toString().padStart(3, "0");
	const nextNumber = (parseInt(currentNumber) + 1).toString().padStart(3, "0");
	
	let prevAndNext = [(dv.pages(tag).where(p => startsWithNumber(p.file.name, prevNumber) || startsWithNumber(p.file.name, nextNumber)).file.name)]
	
	// Prev = [0]; Next = [1]
	let sortedPrevAndNext = sort2Array(prevAndNext[0])
	
	if (currentNumber == "001"){ 
		// Se è la prima pagina aggiungi solo il prossimo
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
	} else if (prevAndNext[0][1] == undefined){
		// Se è l'ultima pagina aggiungi solo il precedente
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	} else {
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
		
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	}
	
	
}

if (dv.current().tags[0] == null || dv.current().tags[0] == undefined){
	dv.header(1, "Errore - Inserire il tag nelle proprietà del file")
} else {
	let tag = "#" + dv.current().tags[0]

	// Purtroppo obsidian non riesce a leggere i link e a creare connessioni nel grafo,
	// quindi ho disattivato il link all'indice automatico e la funzione extractUpperCaseLetters
	//let indexName = "000 Indice " + extractUpperCaseLetters(tag)
	//let index = dv.page(indexName).file
	//let indexLink = "[[" + index.name + "|" + "↖ Ritorna all'indice ↖" + "]]"
	//toDisplay.push(indexLink)
	
	let currentPage = dv.current().file
	let currentPageNumber = extractNumberFromString(currentPage.name)
	
	searchPrevAndNext(tag, currentPageNumber)
	
	dv.list(toDisplay)
}
```

Altri collegamenti: 