---
aliases: 
tags:
  - corsi/informatica/tecnologie_software_web
paragrafo: CSS
cssclasses:
  - 
---
> I **CSS** (*Cascading Style Sheets*) vengono usati per la *formattazione* del testo, componenti grafici o altri elementi [[006 Basi di HTML|HTML]] in un sito web.

---
### Implementazione
Un foglio CSS può essere applicato ad una pagina HTML in tre modi:
1. Metodo *Inline*: si implementa lo stile di un elemento HTML direttamente nella pagina, specificando l'[[007 Elementi e Attributi HTML#ATTRIBUTO|attributo]] `style`, dove il valore è una stringa contenente il codice CSS. Molteplici specifiche vengono separate all'interno della stessa stringa attraverso `;`.
```HTML
<!-- Inline -->
<h1 style="color: red;">Header Rosso</h1>
<h2 style="color: blue; font-style: italic;">Header Blu Corsivo</h2>
```

2. Metodo *Internal*: si inseriscono le specifiche CSS all'interno di un tag `<style>` contenuto in `<head>`.
```HTML
<!-- Internal -->
<head>
	<title>Document</title>
	<style>
		h1{
			color: red;
		}
		h2{
			color: blue;
			font-style: italic;
		}
	</style>
</head>
<body>
	<h1>Header Rosso</h1>
	<h2>Header Blu Corsivo</h2>
</body>
```

3. Metodo *External*: si crea un file `.css` in cui mettere le specifiche CSS. Bisogna linkare al file HTML il file CSS attraverso il tag `<link>` (con degli attributi) contenuto in `<head>`.

```CSS
/* CSS */
h1 {
	color: red;
}
h2 {
	color: blue;
	font-style: italic;
}
```

```HTML
<!-- HTML (External) -->
<head>
	<title>Document</title>
	
	<!-- rel: relazione tra file; href: path per il CSS -->
	<link rel="stylesheet" href="path/to/style.css">
</head>
<body>
	<h1>Header Rosso</h1>
	<h2>Header Blu Corsivo</h2>
</body>
```

> [!success] Quest'ultimo (External) è il metodo migliore

---
### Selettore di Id e Classi
Il CSS è formato da:
- Un **Selettore** (come `h1`, `p`, ecc.) che indica gli elementi HTML ai quali si applicheranno le dichiarazioni CSS;
- Un blocco di dichiarazioni contiene le **Proprietà** CSS e i loro valori.

Un selettore può selezionare sia *un SINGOLO elemento HTML* (mettendo `#`) riconoscibile attraverso il suo ID, oppure può selezionare *una CLASSE di elementi HTML* (mettendo `.`).

Normalmente gli elementi standard all'interno dei tag possono essere selezionati solo attraverso il nome.

```CSS
/* Selezionato un Tag Normale */
h1 {
	color: red;
}

/* Selezionato un qualsiasi elemento con ID idElemento */
#idElemento {
	color: red;
}

/* Selezionato un gruppo di elementi della CLASSE classeElemento */
.classeElemento {
	color: red;
}

/* Selezionato solo i paragrafi che si trovano nella CLASSE classeElemento */
p.classeElemento{
	color: red;
}

/* Selezionato solo i paragrafi che hanno come ID idElemento */
p#idElemento{
	color: red;
}
```

### Pseudo-classi
Le **Pseudo-classi** si applicano ad un sottoinsieme degli elementi di un tipo identificato da un particolare stato di quest'ultimo:
```CSS
tipo_elemento:pseudo-classe{...}
```

> [!example] <font color="orange">Esempio</font>
> Lo stato di un'ancora quando:
> - Il link è normale: `a:link{}`;
> - Il link è stato già visitato: `a:visited{}`;
> - Si passa con il mouse sul link: `a:hover{}`.

___
[[000 Indice TSW|↖ Ritorna all'indice ↖]]

```dataviewjs
/*
function extractUpperCaseLetters(inputString) {
	// Use a regular expression to match uppercase letters (A-Z)
	const uppercaseLetters = inputString.match(/[A-Z]/g);
	
	// Check if uppercaseLetters is not null, and join the matched letters into a string
	if (uppercaseLetters !== null) {
		return uppercaseLetters.join('');
	} else {
	    // If no uppercase letters were found, return an empty string
	    return '';
	}
}
*/

function extractNumberFromString(inputString) {
	const match = inputString.match(/^\d{3}/);
	
	if (match) {
		return match[0];
	} else {
		return null; // Return null if no match is found
	}
}

function startsWithNumber(inputString, targetNumber) {
  // Use a regular expression to check if the string starts with the target number
  const pattern = new RegExp(`^${targetNumber}`);
  return pattern.test(inputString);
}

function sort2Array(array){
	let res = []
	
	if (array[0] == undefined)
		res.push(array[1], array[1])
	else if (array[1] == undefined)
		res.push(array[0], array[0])
	else if (parseInt(extractNumberFromString(array[0])) > parseInt(extractNumberFromString(array[1])))
		res.push(array[1], array[0])
	else
		res.push(array[0], array[1])
	
	return res
}

let toDisplay = []
function searchPrevAndNext(tag, currentNumber) {
	const prevNumber = (parseInt(currentNumber) - 1).toString().padStart(3, "0");
	const nextNumber = (parseInt(currentNumber) + 1).toString().padStart(3, "0");
	
	let prevAndNext = [(dv.pages(tag).where(p => startsWithNumber(p.file.name, prevNumber) || startsWithNumber(p.file.name, nextNumber)).file.name)]
	
	// Prev = [0]; Next = [1]
	let sortedPrevAndNext = sort2Array(prevAndNext[0])
	
	if (currentNumber == "001"){ 
		// Se è la prima pagina aggiungi solo il prossimo
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
	} else if (prevAndNext[0][1] == undefined){
		// Se è l'ultima pagina aggiungi solo il precedente
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	} else {
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
		
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	}
	
	
}

if (dv.current().tags[0] == null || dv.current().tags[0] == undefined){
	dv.header(1, "Errore - Inserire il tag nelle proprietà del file")
} else {
	let tag = "#" + dv.current().tags[0]

	// Purtroppo obsidian non riesce a leggere i link e a creare connessioni nel grafo,
	// quindi ho disattivato il link all'indice automatico e la funzione extractUpperCaseLetters
	//let indexName = "000 Indice " + extractUpperCaseLetters(tag)
	//let index = dv.page(indexName).file
	//let indexLink = "[[" + index.name + "|" + "↖ Ritorna all'indice ↖" + "]]"
	//toDisplay.push(indexLink)
	
	let currentPage = dv.current().file
	let currentPageNumber = extractNumberFromString(currentPage.name)
	
	searchPrevAndNext(tag, currentPageNumber)
	
	dv.list(toDisplay)
}
```

Altri collegamenti: 
- [Bro Code](https://youtu.be/wRNinF7YQqQ)

Cose utili per css:
- Divider (da [Fireship](https://www.youtube.com/watch?v=lPJVi797Uy0))
	- [Shape Divider](https://www.shapedivider.app/): per creare divider curvi;
	- [Haikei](https://haikei.app/): per creare diversi tipi di divider;
- Flexbox (da [Marchetti Design](https://www.youtube.com/watch?v=SGwH2NdVyZE))
	- [Flexbox Playground](https://codepen.io/ndangelo/pen/BaamRam): per vedere come si comportano le flexbox;