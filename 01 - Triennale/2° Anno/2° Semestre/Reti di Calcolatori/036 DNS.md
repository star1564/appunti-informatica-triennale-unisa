---
aliases: [DNS]
tags:
  - corsi/informatica/reti_calcolatori
paragrafo: Livello Applicazione
cssclasses:
  - 
---

>Il **Domain Name System (DNS)** è un [[Database Distribuito]] (decentralizzato) che svolge un ruolo cruciale nella *conversione dei nomi di dominio in [[Indirizzo IP|indirizzi IP]]* e viceversa, facilitando così la comunicazione tra computer e server all'interno della rete.

Il DNS opera come una sorta di "rubrica telefonica" globale per Internet. Ogni dispositivo connesso a Internet ha un indirizzo IP unico, che è una serie numerica difficile da ricordare. Il DNS risolve questo problema consentendo agli utenti di utilizzare *nomi di dominio significativi*, come `example.com`, anziché dover inserire gli indirizzi IP numerici corrispondenti, che sarebbero molto più difficili da memorizzare.

Il DNS può anche svolgere il compito della *distribuzione del carico* tra server replicati di un web server affollato e permettono di creare indirizzi [[025 IPv6|IPv6]] partendo da un [[023 Internet Protocol (IPv4)|IPv4]]: il kernel capisce che si tratta di un indirizzo speciale ed usa la comunicazione IPv4.

## Gerarchia DNS
Il sistema del DNS funziona attraverso una **struttura gerarchica** di server. 

Quando un utente digita un nome di dominio nel proprio browser o esegue qualsiasi altra operazione basata su DNS, il sistema DNS avvia una serie di query che inizia dai root server e scende lungo la gerarchia fino a raggiungere il server DNS autoritativo appropriato per il dominio cercato. Questo server quindi restituisce l'indirizzo IP associato al nome di dominio richiesto, consentendo al dispositivo di stabilire una connessione con il server desiderato.

![[Immagine 2023-09-20 191926.png|700]]

### Server DNS Locale
Questo è il **primo server DNS** a cui un dispositivo si rivolge quando cerca di tradurre un nome di dominio in un indirizzo IP. Se la richiesta non può essere soddisfatta dal server DNS locale, verrà *inoltrata* al server DNS superiore (Root).

Il server DNS locale è configurato *nella rete locale (Internet Service Provider)* o *sul dispositivo dell'host richiedente* ed è responsabile di gestire le richieste DNS localmente. 

Non fa parte ufficialmente della gerarchia DNS.
### Root Server
I **Root** server sono i server di base nella gerarchia del DNS che contengono informazioni sui server DNS dei domini di primo livello (TLD) e *forniscono le fondamenta per la risoluzione dei nomi di dominio* su Internet.

### TLD
I server **TLD** (Top-Level Domain) sono server specializzati che gestiscono e forniscono *informazioni sui domini di primo livello*, come `.com`, `.org` e `.net`, nella gerarchia del DNS.

### Authoritative Server
Al di sotto TLD ci sono i server **Autoritativi**, ovvero i server DNS *responsabili di specifici domini* di secondo livello (SLD, Second-Level Domain). 

I server DNS autoritativi come quelli di `google.com` o `facebook.com` sono responsabili di memorizzare e gestire gli indirizzi IP associati ai nomi di dominio *all'interno del loro dominio specifico*, come `mail.google.com` o `maps.google.com`.

## TIPI DI QUERY
Nel sistema DNS (Domain Name System), ci sono principalmente due tipi di **query** che vengono utilizzati per ottenere informazioni sui nomi di dominio e tradurli in indirizzi IP o viceversa.

### Query Ricorsiva
In una **query ricorsiva**, un client DNS, come un computer o un router, fa una richiesta a un server DNS. Quest'ultimo comunica con altri server DNS per cercare l'indirizzo IP e restituirlo al client.

Se il Server DNS Locale non ha l'indirizzo IP, verrà inoltrata la richiesta al Root Server per poi scendere fino ad arrivare all'Authoritative Server appropriato per il dominio cercato.

Questo significa che *solo il server DNS interrogherà altri server DNS (in una struttura gerarchica)*, se necessario, fino a quando non otterrà una risposta definitiva o un errore.


![[Immagine 2023-09-20 183032.png|500]]


Questo tipo di query è comunemente utilizzato dai client per ottenere informazioni sui nomi di dominio e richiede una risposta completa.

### Query Iterativa
In una **query iterativa**, un server DNS fornisce una risposta basata sulle informazioni disponibili, ma non esegue tutte le operazioni per risolvere completamente la richiesta. 

Se il server DNS consultato possiede le informazioni necessarie per risolvere la richiesta, restituirà una risposta diretta. Tuttavia, se non ha le informazioni, fornirà una lista di server DNS o indirizzi IP a cui il client può rivolgersi successivamente per ulteriori dettagli.

*Il client DNS è quindi responsabile di contattare i vari server DNS* fino a quando non ottiene una risposta completa o raggiunge un server DNS che può risolvere la richiesta. 

![[Immagine 2023-09-20 183321.png|500]]

___
[[000 Indice RC|↖ Ritorna all'indice ↖]]
```dataviewjs
/*
function extractUpperCaseLetters(inputString) {
	// Use a regular expression to match uppercase letters (A-Z)
	const uppercaseLetters = inputString.match(/[A-Z]/g);
	
	// Check if uppercaseLetters is not null, and join the matched letters into a string
	if (uppercaseLetters !== null) {
		return uppercaseLetters.join('');
	} else {
	    // If no uppercase letters were found, return an empty string
	    return '';
	}
}
*/

function extractNumberFromString(inputString) {
	const match = inputString.match(/^\d{3}/);
	
	if (match) {
		return match[0];
	} else {
		return null; // Return null if no match is found
	}
}

function startsWithNumber(inputString, targetNumber) {
  // Use a regular expression to check if the string starts with the target number
  const pattern = new RegExp(`^${targetNumber}`);
  return pattern.test(inputString);
}

function sort2Array(array){
	let res = []
	
	if (array[0] == undefined)
		res.push(array[1], array[1])
	else if (array[1] == undefined)
		res.push(array[0], array[0])
	else if (parseInt(extractNumberFromString(array[0])) > parseInt(extractNumberFromString(array[1])))
		res.push(array[1], array[0])
	else
		res.push(array[0], array[1])
	
	return res
}

let toDisplay = []
function searchPrevAndNext(tag, currentNumber) {
	const prevNumber = (parseInt(currentNumber) - 1).toString().padStart(3, "0");
	const nextNumber = (parseInt(currentNumber) + 1).toString().padStart(3, "0");
	
	let prevAndNext = [(dv.pages(tag).where(p => startsWithNumber(p.file.name, prevNumber) || startsWithNumber(p.file.name, nextNumber)).file.name)]
	
	// Prev = [0]; Next = [1]
	let sortedPrevAndNext = sort2Array(prevAndNext[0])
	
	if (currentNumber == "001"){ 
		// Se è la prima pagina aggiungi solo il prossimo
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
	} else if (prevAndNext[0][1] == undefined){
		// Se è l'ultima pagina aggiungi solo il precedente
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	} else {
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
		
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	}
	
	
}

if (dv.current().tags[0] == null || dv.current().tags[0] == undefined){
	dv.header(1, "Errore - Inserire il tag nelle proprietà del file")
} else {
	let tag = "#" + dv.current().tags[0]

	// Purtroppo obsidian non riesce a leggere i link e a creare connessioni nel grafo,
	// quindi ho disattivato il link all'indice automatico e la funzione extractUpperCaseLetters
	//let indexName = "000 Indice " + extractUpperCaseLetters(tag)
	//let index = dv.page(indexName).file
	//let indexLink = "[[" + index.name + "|" + "↖ Ritorna all'indice ↖" + "]]"
	//toDisplay.push(indexLink)
	
	let currentPage = dv.current().file
	let currentPageNumber = extractNumberFromString(currentPage.name)
	
	searchPrevAndNext(tag, currentPageNumber)
	
	dv.list(toDisplay)
}
```

Altri collegamenti: 
- https://www.youtube.com/watch?v=Dmy3IThKO14