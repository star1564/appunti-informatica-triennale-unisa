---
aliases:
  - TCP
tags:
  - corsi/informatica/reti_calcolatori
paragrafo: Livello Trasporto
cssclasses:
  - 
---
Il **TCP** (*Transmission Control Protocol*) è uno dei principali [[Protocollo|protocolli]] di comunicazione nelle reti. 

>È utilizzato per effettuare una connessione **Connection Oriented** e [[Flusso Trasmissivo#FULL-DUPLEX|Full-duplex]], rendendolo un *protocollo affidabile*: questo significa che la comunicazione tra due dispositivi avviene attraverso un processo di *stabilimento*, *gestione* e *terminazione* di una "connessione" virtuale prima che i dati possano essere scambiati ([[034 Apertura e Chiusura connessione TCP|Handshake]]).

![[Pasted image 20230908160608.png|700]]

Il livello di trasporto che usa TCP suddivide i dati in *pacchetti più piccoli* prima di inviarli attraverso la rete (in ricezione vengono ricomposti).
Questo consente di gestire più facilmente il flusso di dati e di *evitare congestionamenti*. ^ef1e62

## Pacchetto TCP
Un pacchetto TCP è l'unità di dati di base utilizzata per la trasmissione di informazioni tramite il protocollo TCP.

![[Pasted image 20230909111129.png|590]]

> [!info]- Componenti del pacchetto TCP
>- **Porta Sorgente (Source Port):** Questo campo indica la porta di origine del mittente. Indica quale applicazione sul mittente ha generato il pacchetto TCP.
>- **Porta Destinazione (Destination Port):** Questo campo indica la porta di destinazione a cui il pacchetto TCP è destinato. Specifica quale applicazione sul destinatario deve ricevere il pacchetto.
>- **Numero di Sequenza (Sequence Number):** Questo campo contiene il numero di sequenza del pacchetto. Viene utilizzato per *numerare i byte di dati* all'interno del flusso di dati TCP. È fondamentale per il controllo dell'ordine dei pacchetti e la gestione della ritrasmissione.
>- **Numero di Riconoscimento (Acknowledgment Number):** Questo campo contiene il numero di riconoscimento, che indica il prossimo numero di sequenza previsto dal mittente. È utilizzato per confermare la ricezione di dati dal destinatario.
>- **Lunghezza Intestazione (Header Length):** Questo campo specifica la lunghezza dell'intestazione TCP in parole da 32 bit. Serve per individuare l'inizio dei dati nel pacchetto.
>- **Flag TCP:** Questi sono una serie di flag (indicatori) che controllano il comportamento del pacchetto TCP. Alcuni esempi di flag includono il flag SYN (synchronization), ACK (acknowledgment), FIN (finish), e molti altri.
>- **Finestra (Window):** Questo campo indica la dimensione della finestra di ricezione. Rappresenta il numero di byte che il mittente può inviare prima di attendere una conferma dal destinatario.
>- **Checksum:** Il campo checksum contiene un valore di controllo che viene calcolato per verificare l'integrità dei dati e dell'intestazione del pacchetto.
>- **Puntatore Urgente (Urgent Pointer):** Questo campo viene utilizzato in combinazione con il flag URG per indicare dati urgenti all'interno del pacchetto.
>-  **Opzioni (Options):** Questo campo può contenere opzioni aggiuntive per configurare il comportamento della connessione TCP. Le opzioni non sono sempre presenti, ma quando lo sono, possono includere informazioni come il massimo segment size (MSS), il timestamp, ecc.
>-  **Dati (Data):** Questo campo contiene i dati effettivi da trasmettere. La lunghezza dei dati può variare da zero (ad esempio, in un pacchetto con solo flag di controllo) a un valore specifico in base alle dimensioni dei dati trasferiti.

## Consegna pacchetti
Riguardo la consegna dei pacchetti, TCP utilizza il meccanismo [[010 Gestione del Flusso nel Data Link#RDT 3.0 (Sliding Window)|sliding window]] di tipo [[010 Gestione del Flusso nel Data Link#Go-Back-N|Go-Back-N]] con timeout. Se il timeout scade, il pacchetto viene ritrasmesso. 

Il tempo del timeout è stabilito con l'algoritmo del *Round-Trip Time* (RTT).

## Controllo del flusso in TCP
Entrambi gli host della connessione TCP riservano un **buffer di ricezione**, nei quali verranno *collocati i dati* correttamente ricevuti.

L'applicazione leggerà, poi, quei dati direttamente dal buffer, ma non necessariamente nel preciso momento in cui verranno allocati nel buffer.  Ma, se l'applicazione che sta leggendo i dati è lenta, il sender potrebbe *sovraccaricare* l'applicazione che perderà i nuovi dati. 

![[Pasted image 20230909114427.png]]

La soluzione è proprio il **controllo del flusso**, il quale permette di adattare la velocità del mittente con quella del ricevente. Si basa principalmente su due componenti chiave.

### Finestra di Ricezione
La **Finestra di Ricezione** è un meccanismo attraverso il quale il destinatario (il nodo ricevente) comunica al mittente (il nodo trasmittente) *quanta capacità di ricezione ha disponibile*. 

![[Pasted image 20230909120249.png]]

Questa capacità viene espressa in termini di quantità di dati che il destinatario è in grado di accettare e memorizzare nel suo buffer di ricezione. 

Il mittente quindi regola il flusso di dati inviati in base a questa finestra. Se la finestra di ricezione è piccola, il mittente invia meno dati; se è grande, il mittente può inviare più dati.

### Finestra di Congestione
La **Finestra di Congestione** è un meccanismo utilizzato per evitare l'intasamento della rete, imponendo un *limite alla quantità di traffico che un host può inviare* in una connessione. 

Il mittente *monitora costantemente le condizioni della rete* e la velocità con cui il destinatario è in grado di elaborare i dati. 

La finestra di congestione è regolata *dinamicamente* in base a queste informazioni. 
- Se la rete è congestionata o se il destinatario sta ricevendo dati più lentamente del previsto, la finestra di congestione si restringe, limitando la quantità di dati inviati. 
- In caso contrario, la finestra di congestione può espandersi per consentire una trasmissione più rapida.

___
[[000 Indice RC|↖ Ritorna all'indice ↖]]
```dataviewjs
/*
function extractUpperCaseLetters(inputString) {
	// Use a regular expression to match uppercase letters (A-Z)
	const uppercaseLetters = inputString.match(/[A-Z]/g);
	
	// Check if uppercaseLetters is not null, and join the matched letters into a string
	if (uppercaseLetters !== null) {
		return uppercaseLetters.join('');
	} else {
	    // If no uppercase letters were found, return an empty string
	    return '';
	}
}
*/

function extractNumberFromString(inputString) {
	const match = inputString.match(/^\d{3}/);
	
	if (match) {
		return match[0];
	} else {
		return null; // Return null if no match is found
	}
}

function startsWithNumber(inputString, targetNumber) {
  // Use a regular expression to check if the string starts with the target number
  const pattern = new RegExp(`^${targetNumber}`);
  return pattern.test(inputString);
}

function sort2Array(array){
	let res = []
	
	if (array[0] == undefined)
		res.push(array[1], array[1])
	else if (array[1] == undefined)
		res.push(array[0], array[0])
	else if (parseInt(extractNumberFromString(array[0])) > parseInt(extractNumberFromString(array[1])))
		res.push(array[1], array[0])
	else
		res.push(array[0], array[1])
	
	return res
}

let toDisplay = []
function searchPrevAndNext(tag, currentNumber) {
	const prevNumber = (parseInt(currentNumber) - 1).toString().padStart(3, "0");
	const nextNumber = (parseInt(currentNumber) + 1).toString().padStart(3, "0");
	
	let prevAndNext = [(dv.pages(tag).where(p => startsWithNumber(p.file.name, prevNumber) || startsWithNumber(p.file.name, nextNumber)).file.name)]
	
	// Prev = [0]; Next = [1]
	let sortedPrevAndNext = sort2Array(prevAndNext[0])
	
	if (currentNumber == "001"){ 
		// Se è la prima pagina aggiungi solo il prossimo
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
	} else if (prevAndNext[0][1] == undefined){
		// Se è l'ultima pagina aggiungi solo il precedente
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	} else {
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
		
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	}
	
	
}

if (dv.current().tags[0] == null || dv.current().tags[0] == undefined){
	dv.header(1, "Errore - Inserire il tag nelle proprietà del file")
} else {
	let tag = "#" + dv.current().tags[0]

	// Purtroppo obsidian non riesce a leggere i link e a creare connessioni nel grafo,
	// quindi ho disattivato il link all'indice automatico e la funzione extractUpperCaseLetters
	//let indexName = "000 Indice " + extractUpperCaseLetters(tag)
	//let index = dv.page(indexName).file
	//let indexLink = "[[" + index.name + "|" + "↖ Ritorna all'indice ↖" + "]]"
	//toDisplay.push(indexLink)
	
	let currentPage = dv.current().file
	let currentPageNumber = extractNumberFromString(currentPage.name)
	
	searchPrevAndNext(tag, currentPageNumber)
	
	dv.list(toDisplay)
}
```

Altri collegamenti: 