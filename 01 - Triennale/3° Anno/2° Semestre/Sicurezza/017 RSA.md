---
aliases: 
tags:
  - corsi/informatica/sicurezza
paragrafo: Algoritmi di Crittografia
cssclasses:
  - 
---
>L'algoritmo di **RSA** è di tipo [[005 Cifrari Asimmetrici|asimmetrico]] dove il testo in chiaro ed il testo cifrato sono degli *interi tra $0$ ed $n-1$*, con un $n$ fissato. 
>In particolare, è una [[005 Cifrari Asimmetrici#Cifratura con Chiave Pubblica|Cifratura con Chiave Pubblica]].
>
>Questo utilizza principalmente i numeri [[042 Numeri Primi|primi]] e [[047 Numeri Coprimi|coprimi]] per la crittografia e decifrazione di un messaggio.

### Algoritmo dell'RSA
Il testo in chiaro viene crittografato in blocchi, con ogni blocco avente un valore binario inferiore a un certo intero $\color{#fdaa39}n$. Inoltre, sono presenti due chiavi:
- $(\textcolor{#61AFEF}{e}, \textcolor{#fdaa39}n)$ - Chiave pubblica, composta da un intero per criptare il testo in chiaro $\textcolor{#61AFEF}{e}$
- $(\textcolor{#61AFEF}{d}, \textcolor{#fdaa39}n)$ - Chiave privata, composta da un intero per decifrare il testo in chiaro $\textcolor{#61AFEF}{d}$

La crittografia e la decifrazione sono della forma seguente, per un blocco di <font color="#FF6611">testo in chiaro $M$</font> e un blocco di <font color="#00C575">testo cifrato $C$</font>:
$$\textcolor{#00C575}{C}=\textcolor{#FF6611}{M}^\textcolor{#61AFEF}{e}(\text{mod }\textcolor{#fdaa39}{n})$$
$$\textcolor{#FF6611}{M}=\textcolor{#00C575}{C}^\textcolor{#61AFEF}{d}(\text{mod }\textcolor{#fdaa39}{n})$$

Entrambi il mittente ed il destinatario conoscono $\color{#fdaa39}n$, solo il mittente conosce $\textcolor{#61AFEF}{e}$, solo il destinatario conosce $\textcolor{#61AFEF}{d}$.

> [!example]- <font color="orange">Esempio</font>
>Encryption: $(\textcolor{#61AFEF}{5}, \textcolor{#fdaa39}{14})$
>Text: $\text{B}\to2$
>$$2^\textcolor{#61AFEF}{5}(\text{mod }\textcolor{#fdaa39}{14})=\textcolor{#00C575}{4\to \text{D}}$$
>
>Decryption: $(\textcolor{#61AFEF}{11}, \textcolor{#fdaa39}{14})$
>Text: $\text{D}\to4$
>$$4^\textcolor{#61AFEF}{11}(\text{mod }\textcolor{#fdaa39}{14})=\textcolor{#FF6611}{2\to \text{B}}$$

### Calcolo dei numeri per l'RSA
Per impostare correttamente le due chiavi, bisogna seguire i seguenti passaggi:
1. Calcolare $\textcolor{#fdaa39}{n}$ - Questo numero viene calcolato attraverso una *moltiplicazione tra due numeri primi* **$p$ e $q$**. Questi due numeri dovranno avere una lunghezza pari alla metà dell'input. $$\textcolor{#fdaa39}{n}=p\cdot q$$ Da notare che questi due numeri in situazioni reali dovranno essere estremamente grandi.
2. Calcolare $\phi(\textcolor{#fdaa39}{n})$ - Ovvero la *quantità di numeri che sono coprimi con $\textcolor{#fdaa39}{n}$*. $$\phi(\textcolor{#fdaa39}{n})=(p-1)\cdot(q-1)$$
3. Calcolare $\textcolor{#61AFEF}{e}$ tramite le seguenti regole:
	- $1<\textcolor{#61AFEF}{e}<\phi(\textcolor{#fdaa39}{n})$
	- $\textcolor{#61AFEF}{e}$ deve essere coprimo con $\phi(\textcolor{#fdaa39}{n})$

4. Calcolare $\textcolor{#61AFEF}{d}$ tramite la seguente equazione: $$\textcolor{#61AFEF}{e}\cdot \textcolor{#61AFEF}{d}(\text{mod }\phi(\textcolor{#fdaa39}{n}))=1$$

> [!example]- <font color="orange">Esempio</font>
>Considerando l'esempio di prima: 
>- $n=14=7\cdot 2$
>- $e=5$, perché è coprimo con $6=\phi(14)=(7-1)(2-1)$
>- $d=11$, perché $5\cdot 11(\text{mod } 6)=55(\text{mod } 6)=1(\text{mod } 6)=1$. Da notare che si possono scegliere tutti i numeri per cui questo risultato è $1$.


> [!info]- Approccio Generale
> ![[Pasted image 20240614092508.png]]
ù

> [!question]+ Messaggi più grandi del modulo
> RSA viene usato per cifrare una chiave scelta casualmente che poi verrà usata per cifrare il messaggio mediante un cifrario simmetrico.


## Sicurezza dell'RSA
Ci sono diversi tipi di attacchi possibili all'RSA.

> [!question]+ Rompere AES 256 e RSA 2048
> Non si sa se rompere [[013 Advanced Encryption Standard|AES]] 256 e rompere RSA 2048 bit sono due problemi correlati tra loro, cioè un algoritmo efficiente per rompere uno dei due può essere usato per rompere l'altro.

### Attacchi Matematici
#### Sicurezza delle chiavi
Un attaccante che conosce la chiave pubblica $(e,n)$ vuole calcolare la chiave privata $$d=e^{-1}(\text{mod }\phi(n))$$
Ci sono tre approcci per attaccare matematicamente il sistema di generazione delle chiavi:
1. Derivare da $n$ i due numeri primi che, moltiplicati tra di loro, lo formano. Ovvero *fattorizzare $n$* nei suoi due numeri primi $p$ e $q$. Questo permette di calcolare $\phi(n)$ e quindi anche $d$. È chiamato il **problema della fattorizzazione**.
2. Determinare *$\phi(n)$ direttamente*, senza trovare $p$ e $q$. Questo permette di trovare $d$. Si sostituisce $p$ con $n/q$, quindi abbiamo [[MB - 08 Equazioni di Secondo Grado|l'equazione di secondo grado]] seguente $p^2-(n-\phi(n)+1)p+n=0$, dove le due soluzioni saranno $p$ e $q$.
3. Determinare *$d$ direttamente*, senza trovare $\phi(n)$. Un algoritmo che computa $d$ (con input $n,e$) può essere usato come [[008 Oracolo e Driver|oracolo]] in un algoritmo *Las Vegas* che fattorizza $n$ con [[016 Definizione di Probabilità|probabilità]] $\geq 0.5$.

#### Problema della Fattorizzazione
Si può notare che *computare $d$ è equivalente a fattorizzare $n$*.

Per calcolare i due numeri primi $p,q$ dato $n$, tale che $pq=n$, quando $n$ è grande questo è un problema computazionalmente difficile. Infatti, si ha una *[[051 Complessità di Tempo|complessità di tempo]] sub-esponenziale* in media.

>Per tutti i numeri primi $p$ nell'intervallo $[\ 2, \sqrt{n}\ ]$, se $p$ [[039 Divisibilità|divide]] $n$ (ovvero $p|n$), allora $p$ è fattore di $n$.

> [!example]- <font color="orange">Esempio</font>
>Se $n=77$, i numeri primi nell'intervallo che dividono $n$ sono: $2,3,5,7$

La complessità di tempo nel caso peggiore è esponenziale nella lunghezza dell'input.

> [!info]+ Scelta dei numeri primi
>Ad oggi, i numeri più difficili da fattorizzare sono sempre del tipo $n = p\cdot q$ con $p,q$ primi *della stessa lunghezza*. 
>Queste chiavi devono essere di almeno 2048 bit (almeno fino al 2030).

#### Sicurezza della cifratura
Questo è sempre inerente al problema della fattorizzazione.
Un attaccante che conosce la chiave pubblica $(e,n)$ e il messaggio cifrato $C$, vuole calcolare il testo in chiaro $M$.

Se l'attaccante potesse fattorizzare $n$ potrebbe anche computare $M$:
1. Fattorizza $n$
2. Computa $\phi(n)$
3. Computa $d$
4. Ricava $M$ decifrando $C$

### Chosen Ciphertext Attack
Il CCA è definito come un attacco in cui l'attaccante *sceglie specifici testi cifrati* e riceve i corrispondenti testi in chiaro, decifrati con la chiave privata dell'obiettivo.

In questo modo, l'attaccante potrebbe scegliere un testo in chiaro specifico, cifrarlo con la chiave pubblica dell'obiettivo e poi essere in grado di recuperare il testo in chiaro decifrandolo con la chiave privata. Chiaramente, ciò non fornisce all'attaccante alcuna nuova informazione. 

Invece, l'attaccante sfrutta le proprietà di RSA e seleziona blocchi di dati che, una volta elaborati con la chiave privata dell'obiettivo, forniscono informazioni necessarie per la [[003 Crittografia#^20ecc3|Crittoanalisi]].

> [!note]+ Public-Key Cryptography Standards per la **CIFRATURA** (PKCS #1)
> > [!warning] Da non confondere con quello [[023 Firme con RSA#^3198fd|per la firma]]
> > Quello per la cifratura utilizza i nomi RSA_AES.
> 
> In esso sono descritti due schemi per la *cifratura*:
>- **RSA_AES-PKCS1-v1_5**: Ci sono problemi di sicurezza.
>- **RSA_AES-OAEP**, *Optimal Asymmetric Encryption Padding (OAEP)*: Questo rende *casuale* il messaggio da cifrare. Viene usato quando si vogliono *evitare gli attacchi CCA* (Chosen Ciphertext Attack).

^f71696






___
[[000 Indice Sicurezza|↖ Ritorna all'indice ↖]]

```dataviewjs
/*
function extractUpperCaseLetters(inputString) {
	// Use a regular expression to match uppercase letters (A-Z)
	const uppercaseLetters = inputString.match(/[A-Z]/g);
	
	// Check if uppercaseLetters is not null, and join the matched letters into a string
	if (uppercaseLetters !== null) {
		return uppercaseLetters.join('');
	} else {
	    // If no uppercase letters were found, return an empty string
	    return '';
	}
}
*/

function extractNumberFromString(inputString) {
	const match = inputString.match(/^\d{3}/);
	
	if (match) {
		return match[0];
	} else {
		return null; // Return null if no match is found
	}
}

function startsWithNumber(inputString, targetNumber) {
  // Use a regular expression to check if the string starts with the target number
  const pattern = new RegExp(`^${targetNumber}`);
  return pattern.test(inputString);
}

function sort2Array(array){
	let res = []
	
	if (array[0] == undefined)
		res.push(array[1], array[1])
	else if (array[1] == undefined)
		res.push(array[0], array[0])
	else if (parseInt(extractNumberFromString(array[0])) > parseInt(extractNumberFromString(array[1])))
		res.push(array[1], array[0])
	else
		res.push(array[0], array[1])
	
	return res
}

let toDisplay = []
function searchPrevAndNext(tag, currentNumber) {
	const prevNumber = (parseInt(currentNumber) - 1).toString().padStart(3, "0");
	const nextNumber = (parseInt(currentNumber) + 1).toString().padStart(3, "0");
	
	let prevAndNext = [(dv.pages(tag).where(p => startsWithNumber(p.file.name, prevNumber) || startsWithNumber(p.file.name, nextNumber)).file.name)]
	
	// Prev = [0]; Next = [1]
	let sortedPrevAndNext = sort2Array(prevAndNext[0])
	
	if (currentNumber == "001"){ 
		// Se è la prima pagina aggiungi solo il prossimo
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
	} else if (prevAndNext[0][1] == undefined){
		// Se è l'ultima pagina aggiungi solo il precedente
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	} else {
		let nextLink = "[[" + sortedPrevAndNext[1] + "|" + "Nota Successiva →" + "]]"
		toDisplay.push(nextLink)
		
		let prevLink = "[[" + sortedPrevAndNext[0] + "|" + "← Nota Precedente" + "]]"
		toDisplay.push(prevLink)
	}
	
	
}

if (dv.current().tags[0] == null || dv.current().tags[0] == undefined){
	dv.header(1, "Errore - Inserire il tag nelle proprietà del file")
} else {
	let tag = "#" + dv.current().tags[0]

	// Purtroppo obsidian non riesce a leggere i link e a creare connessioni nel grafo,
	// quindi ho disattivato il link all'indice automatico e la funzione extractUpperCaseLetters
	//let indexName = "000 Indice " + extractUpperCaseLetters(tag)
	//let index = dv.page(indexName).file
	//let indexLink = "[[" + index.name + "|" + "↖ Ritorna all'indice ↖" + "]]"
	//toDisplay.push(indexLink)
	
	let currentPage = dv.current().file
	let currentPageNumber = extractNumberFromString(currentPage.name)
	
	searchPrevAndNext(tag, currentPageNumber)
	
	dv.list(toDisplay)
}
```

Altri collegamenti: 
1. [Mental Outlaw](https://www.youtube.com/watch?v=ZPXVSJnDA_A)
2. [Eddie Woo - Part 1](https://www.youtube.com/watch?v=4zahvcJ9glg)
3. [Eddie Woo - Part 2](https://www.youtube.com/watch?v=oOcTVTpUsPQ)